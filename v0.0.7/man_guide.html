<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basics · ComputationGraphs</title><meta name="title" content="Basics · ComputationGraphs"/><meta property="og:title" content="Basics · ComputationGraphs"/><meta property="twitter:title" content="Basics · ComputationGraphs"/><meta name="description" content="Documentation for ComputationGraphs."/><meta property="og:description" content="Documentation for ComputationGraphs."/><meta property="twitter:description" content="Documentation for ComputationGraphs."/><meta property="og:url" content="https://documenter.juliadocs.org/stable/man_guide.html"/><meta property="twitter:url" content="https://documenter.juliadocs.org/stable/man_guide.html"/><link rel="canonical" href="https://documenter.juliadocs.org/stable/man_guide.html"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ComputationGraphs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">User manual</span><ul><li class="is-active"><a class="tocitem" href="man_guide.html">Basics</a><ul class="internal"><li><a class="tocitem" href="#What-is-a-*computation-graph*?"><span>What is a <em>computation graph</em>?</span></a></li><li><a class="tocitem" href="#Building-a-computation-graph"><span>Building a computation graph</span></a></li><li><a class="tocitem" href="#Using-a-computation-graph"><span>Using a computation graph</span></a></li><li><a class="tocitem" href="#Reusing-computations"><span>Reusing computations</span></a></li></ul></li><li><a class="tocitem" href="man_differentiation.html">Symbolic differentiation</a></li><li><a class="tocitem" href="man_recipes.html">Recipes</a></li><li><a class="tocitem" href="man_code_generation.html">Code generation</a></li><li><a class="tocitem" href="examples.html">Examples</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="lib_representation.html">Representation of computation graphs</a></li><li><a class="tocitem" href="lib_public.html">API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User manual</a></li><li class="is-active"><a href="man_guide.html">Basics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="man_guide.html">Basics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/HespanhaPublic/ComputationGraphs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/HespanhaPublic/ComputationGraphs.jl/blob/main/docs/src/man_guide.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h1><p><code>ComputationGraphs</code> is about improving the speed (and energy consumption) of numerical computations that need to be performed repeatedly, e.g.,</p><ul><li>one iteration of a numerical optimization algorithm, </li><li>one iteration of a filtering/smoothing algorithm,</li><li>repeated calls to a classification algorithm on different samples, etc.</li></ul><p>The computation to be performed is encoded into a data structure <a href="lib_public.html#ComputationGraphs.ComputationGraph">ComputationGraph</a> that permits several forms of &quot;run-time&quot; optimization, including:</p><ul><li>allocation-free operation</li><li>(partial) re-use of perviously performed computations</li><li>symbolic differentiation</li><li>symbolic algebraic simplifications </li></ul><h2 id="What-is-a-*computation-graph*?"><a class="docs-heading-anchor" href="#What-is-a-*computation-graph*?">What is a <em>computation graph</em>?</a><a id="What-is-a-*computation-graph*?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-a-*computation-graph*?" title="Permalink"></a></h2><p>A <em>computation graph</em> represents a set of mathematical operations,   performed over a set of variables. Formally, it is represented as a <em>graph</em> with:</p><ul><li><p><em>nodes</em> that correspond to variables that hold the result of a mathematical operation, and </p></li><li><p><em>edges</em> that encode the <em>operands</em> used by each mathematical operation.</p></li></ul><p>The edges are directed from the operand (which we call the &quot;parent node&quot;) to the result of the operation (which we call the &quot;child node&quot;)</p><p>For example, the formula</p><p class="math-container">\[    e = \| A\, x -b \|^2\]</p><p>can be represented by the following tree</p><pre><code class="nohighlight hljs">norm2(A*x-b) (operation is squared-norm \| \|^2)
│
A*x-b        (operation is subtraction -)
│
├── A*x      (operation is multiplication *)
│   ├── A
│   └── x
└── b</code></pre><p>We can recognize two types of nodes:</p><ol><li><code>A</code>, <code>x</code>, and <code>x</code> are <em>varible nodes</em> that are associated with &quot;inputs&quot; to the computation, and</li><li><code>A*x</code>, <code>A*x-b</code>, and <code>norm2(A*x-b)</code> are <em>computation nodes</em> that are associated with some algebraic operation.</li></ol><p>We will often use the expression &quot;evaluate a (computation) node&quot; to mean &quot;perform the operation associated with a node&quot;. For example, by &quot;evaluate the node <code>A*x-b</code>&quot; we mean:</p><ol><li>first fetch the value of the parent node <code>A*x</code>,</li><li>then fetch the value of the other parent node `<code>b</code>,</li><li>and finally subtract these two values to obtain the value of the child node <code>A*x-b</code>.</li></ol><p>Since step 1) involves a computation node, this step presumes that the parent node <code>A*x</code> has been previously evaluated and the value of this evaluation has been saved; otherwise this node would need to be evaluated, prior to step 1).</p><p>Computation graphs are represented by the structures <a href="lib_public.html#ComputationGraphs.ComputationGraph">ComputationGraph</a>, which encode the graph itself as well as additional information about the variables (size, types, whether the node has been evaluated, its stored value, etc).</p><div class="admonition is-info" id="Note-f3d1b0ff0dc46c63"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f3d1b0ff0dc46c63" title="Permalink"></a></header><div class="admonition-body"><p>While missing from this example, a third type of node is possible: <em>constant</em> nodes are also associated with &quot;inputs&quot; to the computation (like <em>variable</em> nodes), but they never change. Declaring &quot;input&quot; nodes as constants typically enables computational savings.</p></div></div><h2 id="Building-a-computation-graph"><a class="docs-heading-anchor" href="#Building-a-computation-graph">Building a computation graph</a><a id="Building-a-computation-graph-1"></a><a class="docs-heading-anchor-permalink" href="#Building-a-computation-graph" title="Permalink"></a></h2><p>The computation graph above can be created using the following code</p><pre><code class="language-julia hljs">using ComputationGraphs
graph = ComputationGraph(Float64)
A = variable(graph, 4, 3)
x = variable(graph, 3)
b = variable(graph, 4)
e = @add graph norm2(A*x-b)</code></pre><p>Upon execution <code>graph</code> represents a 6-node computation graph:</p><ol><li>The 1st assignment creates an empty graph</li><li>The 2nd assignment creates a variable that stores a 4x3 matrix</li><li>The 3rd and 4th assignments create 2 variables that store vectors with sizes 3 and 4, respectively.</li><li>The 5th assignment adds nodes to the graph that store the values of <code>A*x</code>, <code>A*X-b</code>, and <code>norm2(A*X-b)</code>.</li></ol><p>This code only <em>defines</em> a computation graph, but it actually does not performed any computation.</p><p>A computation graph may include several computations that share common variables. For example, we could add to the same graph the computation of the gradient of <code>e</code> with respect to <code>x</code>, which turns out to be</p><p class="math-container">\[\nabla_x e = 2A&#39;(A\,x-b)\]</p><p>This can be added to the existing computation graph using</p><pre><code class="language-julia hljs">grad = @add graph constant(2.0) * adjointTimes(A, A*x - b )</code></pre><p>This command will recognize that the existing graph already nodes for <code>A*x</code> and <code>A*x-b</code> so only 3 more nodes need to be added: the constant value <code>2</code> and the products <code>A&#39;*(A*x-b)</code>, <code>2*A&#39;*(A*x-b)</code>; resulting in a graph with 9 nodes.</p><p>The reuse of nodes has important implications in terms of reusing computation. Specifically, </p><ol><li>Once we compute the gradient <span>$\nabla_x e$</span>, the term <code>A*x-b</code> becomes available and computing <code>e</code> only requires computing <a href="lib_public.html#ComputationGraphs.norm2">norm2</a> of <code>A*x-b</code>, which is a relatively &quot;cheap&quot; computation.</li><li>Alternatively, if we first compute <code>e</code>, then  <code>A*x-b</code> becomes available and computing the gradient only requires multiplying it by <code>2*A</code>.</li></ol><p>In either case, we can share intermediate results between the computations of <code>e</code> and <span>$\nabla_x e$</span>. </p><div class="admonition is-info" id="Note-bf0cdd65b0e5c369"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-bf0cdd65b0e5c369" title="Permalink"></a></header><div class="admonition-body"><p>We used <code>adjointTimes(M,N)</code> to represent the operation <code>M&#39;*N</code>, which really consists of two operations: taking the adjoint/transpose of the first matrix and then multiplying it by the second matrix.</p><p>In practice, it is generally more efficient (in terms of time and memory) to combine the two operations into a single one, which is generally automatically done by <code>LinearAlgebra</code>. </p><p>We currently force the user to explicitly decide whether or not to combine the two operations by using</p><ul><li><code>adjointTimes(M,n)</code> – combine, or</li><li><code>adjoint(M)*N</code> – do not combine.</li></ul><p>The later option can be better if <code>adjoint(M)</code> will turn out to be useful for other computations.</p></div></div><div class="admonition is-warning" id="Warning-8cfd7b06b9f0d983"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-8cfd7b06b9f0d983" title="Permalink"></a></header><div class="admonition-body"><p>Currently, <code>ComputationGraphs</code> only supports a relatively small set of algebraic operations. These are expected to grow and the package matures.</p></div></div><h2 id="Using-a-computation-graph"><a class="docs-heading-anchor" href="#Using-a-computation-graph">Using a computation graph</a><a id="Using-a-computation-graph-1"></a><a class="docs-heading-anchor-permalink" href="#Using-a-computation-graph" title="Permalink"></a></h2><p>The creation of a computation graph encodes relationships between variables, but does not actually perform any computation. To perform computations we need to:</p><ul><li>first set the values of all variables that appear in the graph, and</li><li>second carryout the computations (in the appropriate order)</li></ul><p>The first step uses the <a href="lib_public.html#ComputationGraphs.set!">set!</a> command to set the values of variable:</p><pre><code class="language-julia hljs">set!(graph, A, [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0; 10.0 11.0 12.0])
set!(graph, x, [1.0, 1.0, 1.0])
set!(graph, b, [2.0, 2.0, 2.0, 2.0])</code></pre><p>We are now ready to perform the graph computations using <a href="lib_public.html#ComputationGraphs.compute!">compute!</a>, which can take two forms: To recompute the whole graph, we can use</p><pre><code class="language-julia hljs">compute!(graph)</code></pre><p>but if we just want to recompute the portion of the graph needed to evaluate the node <code>e</code>, we can use</p><pre><code class="language-julia hljs">compute!(graph, e)</code></pre><p>Finally, we can get the value of <code>e</code> using <a href="lib_public.html#Base.get">get</a></p><pre><code class="language-julia hljs">value = get(graph,e)
println(value)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">fill(1630.0)</code></pre><div class="admonition is-info" id="Note-6144adc3215c412f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-6144adc3215c412f" title="Permalink"></a></header><div class="admonition-body"><p>The values of all nodes in a computation graph are stored as N-dimensional arrays. Vectors are 1-dimensional arrays, matrices 2-dimensional arrays, but higher dimensional arrays can also be used in ComputationGraphs</p><p>Scalars turn out to also be represented as arrays, but 0-dimensional arrays, which in julia always have a single element. 0-dimensional arrays can be created using <code>fill(value)</code> and are displayed as <code>fill(value)</code>:</p><pre><code class="language-julia hljs">x = fill(1.0)
println(x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">fill(1.0)</code></pre></div></div><h2 id="Reusing-computations"><a class="docs-heading-anchor" href="#Reusing-computations">Reusing computations</a><a id="Reusing-computations-1"></a><a class="docs-heading-anchor-permalink" href="#Reusing-computations" title="Permalink"></a></h2><p>The structure <a href="lib_public.html#ComputationGraphs.ComputationGraph">ComputationGraph</a> encodes all the dependencies between the nodes of a computation graph, which enables minimizing computation by maximizing the re-use of computations that have been previously performed.</p><h3 id="Doing-all-the-*necessary*-computations,-but-no-more-than-that"><a class="docs-heading-anchor" href="#Doing-all-the-*necessary*-computations,-but-no-more-than-that">Doing all the <em>necessary</em> computations, but no more than that</a><a id="Doing-all-the-*necessary*-computations,-but-no-more-than-that-1"></a><a class="docs-heading-anchor-permalink" href="#Doing-all-the-*necessary*-computations,-but-no-more-than-that" title="Permalink"></a></h3><p>The goal of the <code>compute!(graph)</code> is to make sure that all nodes hold <em>valid value</em>. This does not mean that the function needs to recompute all nodes, since some nodes may have been previously compute and thus may already hold valid values.</p><p>This means that if we call <code>compute!(graph)</code> twice, the second time will actually not perform any computation. This can be seen in the following example that &quot;fools&quot; <code>@benchmark</code> into believing that the operation <span>$\|Ax-b\|$</span> for very large matrices/vectors only takes a few nano seconds.</p><pre><code class="language-julia hljs">using ComputationGraphs, BenchmarkTools
graph = ComputationGraph(Float64)
A = variable(graph, rand(Float64,4000, 3000))
x = variable(graph, rand(Float64,3000))
b = variable(graph, rand(Float64,4000))
e = @add graph norm2(A*x-b)
using BenchmarkTools
bmk=@benchmark compute!($graph)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 999 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">8.654 ns</span></span> … <span class="sgr35">26.065 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">8.675 ns              </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">8.762 ns</span></span> ± <span class="sgr32"> 0.772 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

  <span class="sgr34">█</span> <span class="sgr32"> </span>                                                        
  <span class="sgr34">█</span>▄<span class="sgr32">▁</span>▁▂▂▂▂▁▁▁▁▁▂▂▂▁▁▁▁▁▂▁▂▁▁▁▁▁▂▁▂▁▁▂▁▂▂▁▂▁▂▁▁▁▁▂▁▁▁▁▁▁▁▁▂▁▂ ▂
  8.65 ns<span class="sgr90">        Histogram: frequency by time</span>          12 ns <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code></pre><p>To prevent computation re-use, we can use the keyword <code>force=true</code> to force <a href="lib_public.html#ComputationGraphs.compute!">compute!</a> to actually redo the computations:</p><pre><code class="language-julia hljs">using ComputationGraphs, BenchmarkTools
graph = ComputationGraph(Float64)
A = variable(graph, rand(Float64,4000, 3000))
x = variable(graph, rand(Float64,3000))
b = variable(graph, rand(Float64,4000))
e = @add graph norm2(A*x-b)
using BenchmarkTools
bmk=@benchmark compute!($graph,force=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 5356 samples with 1 evaluation per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">2.526 ms</span></span> … <span class="sgr35">  4.667 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">2.762 ms               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">2.792 ms</span></span> ± <span class="sgr32">144.474 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

           ▁▄▄▆▆▆█▇▇<span class="sgr34">▆</span>▄▄<span class="sgr32">▅</span>▁▂▁▁                                  
  ▁▁▂▂▃▄▅▇██████████<span class="sgr34">█</span>██<span class="sgr32">█</span>████▇▇▇▆▅▄▄▅▅▄▄▄▃▃▃▂▂▂▂▁▂▂▁▁▁▁▂▂▁▁▁▁▁ ▄
  2.53 ms<span class="sgr90">         Histogram: frequency by time</span>        3.29 ms <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code></pre><p>We now see that the computation actually takes a few milliseconds.</p><h3 id="Partial-graph-computations"><a class="docs-heading-anchor" href="#Partial-graph-computations">Partial-graph computations</a><a id="Partial-graph-computations-1"></a><a class="docs-heading-anchor-permalink" href="#Partial-graph-computations" title="Permalink"></a></h3><p>As noted above, the function <a href="lib_public.html#ComputationGraphs.compute!">compute!</a> can be made node-specific; meaning that it only recomputes the set of nodes that are &quot;need&quot; to get the value of a specific node. Also in this case, &quot;parent nodes&quot; that already hold <em>valid values</em> do not need to be recomputed.</p><p>The function <a href="lib_public.html#Base.get">get</a> also checks if the desired node has a <em>valid value</em> and recomputes the node if it does not. Specifically, <code>get(graph,node)</code> implicitly calls <code>compute(graph,node)</code> before returning the value of the node. This means that in the following examples the 2nd function will actually never do any computation:</p><pre><code class="language-julia hljs">compute!(graph)
compute!(graph, e)   # no computation</code></pre><pre><code class="language-julia hljs">compute!(graph, e)
value=get(graph, e)  # no computation, just returns value</code></pre><pre><code class="language-julia hljs">value=get(graph, e)
compute!(graph, e)   # no computation</code></pre><h3 id="Redoing-computations-when-*necessary*"><a class="docs-heading-anchor" href="#Redoing-computations-when-*necessary*">Redoing computations when <em>necessary</em></a><a id="Redoing-computations-when-*necessary*-1"></a><a class="docs-heading-anchor-permalink" href="#Redoing-computations-when-*necessary*" title="Permalink"></a></h3><p>Initialization of updates in variables are prompted by calling either of the following two functions:</p><ul><li><p><code>set!(graph, variable, value)</code> sets the value of the node <code>variable</code> (which must have been created using the command <a href="lib_public.html#ComputationGraphs.variable">variable</a>) to the value of the array <code>value</code>.</p></li><li><p><code>coptyto!(graph, node1, node2)</code> copies the value of the node <code>node2</code> to the node <code>variable</code> (which must have been created using the command <a href="lib_public.html#ComputationGraphs.variable">variable</a>).</p></li></ul><p>When the values of input variables are changed, some (but not necessarily all) nodes may need to be recomputed. </p><ul><li><p>For example, if we use <a href="lib_public.html#ComputationGraphs.set!">set!</a> or <a href="lib_public.html#Base.copyto!">copyto!</a> to change the values of the three variables <code>A</code>, <code>x</code>, <code>b</code>, their children nodes <code>A*x</code>, <code>A*x-b</code>, and <code>norm2(A*x-b)</code> need to be recomputed.</p></li><li><p>However, if we only use <a href="lib_public.html#ComputationGraphs.set!">set!</a> or <a href="lib_public.html#Base.copyto!">copyto!</a> to change the value of <code>b</code>, the node <code>A*x</code> does not need to be recomputed.</p></li></ul><p>The functions <a href="lib_public.html#ComputationGraphs.set!">set!</a> and <a href="lib_public.html#Base.copyto!">copyto!</a> are &quot;smart&quot; in the sense that they keeps track of these dependencies and only marks as &quot;invalid&quot; the &quot;children&quot; of the variable that has been changes. The following examples illustrate this: In the first case, the value of <code>x</code> is set so recomputing <code>e</code> requires recomputing the &quot;expensive&quot; product <code>A*x</code>:</p><pre><code class="language-julia hljs">using ComputationGraphs, BenchmarkTools
graph = ComputationGraph(Float64)
A = variable(graph, rand(Float64,4000, 3000))
x = variable(graph, rand(Float64,3000))
b = variable(graph, rand(Float64,4000))
e = @add graph norm2(A*x-b)
x0=rand(Float64,size(x))
bmk=@benchmark begin
        set!($graph, $x, $x0)   # x changes so A*x and A*x-b need to be recomputed
        value=get($graph, $e)
    end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 1721 samples with 1 evaluation per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">2.590 ms</span></span> … <span class="sgr35">  3.932 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">2.879 ms               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">2.896 ms</span></span> ± <span class="sgr32">143.081 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

              ▂▁▅▁▃▃▄▅▃█▅<span class="sgr34">▄</span><span class="sgr32">▅</span>▂▅▄▁▁▁▂▁▁                          
  ▂▂▃▃▄▄▄▅▆▆█▆███████████<span class="sgr34">█</span><span class="sgr32">█</span>█████████▇▅▅▄▆▅▅▄▅▅▃▄▃▂▃▂▃▃▃▂▂▂▁▂▂ ▅
  2.59 ms<span class="sgr90">         Histogram: frequency by time</span>        3.33 ms <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code></pre><p>In this example, only the value of <code>b</code> is set so recomputing <code>e</code> can reuse the previous value of <code>A*x</code>. Subtractring the new <code>b</code> and taking the norm are much &quot;cheaper&quot; operations ans the compute time decreases from milliseconds to microseconds: </p><pre><code class="language-julia hljs">b0=rand(Float64,size(b))
bmk=@benchmark begin
        set!($graph, $b, $b0)   # b changes so A*x does not need to be recomputed
        value=get($graph, $e)
    end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 9 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">2.596 μs</span></span> … <span class="sgr35">  6.518 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">2.618 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">2.650 μs</span></span> ± <span class="sgr32">175.610 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

  ▆<span class="sgr34">█</span>▃<span class="sgr32">▁</span>▁ ▁                                                     ▁
  █<span class="sgr34">█</span>█<span class="sgr32">█</span>████▇▆▅▅▅▅▃▅▄▄▅▅▅▅▄▃▃▃▃▃▁▁▁▁▄▃▁▃▃▁▃▁▅▃▄▄▃▁▁▄▃▁▁▅▅▆▇█▇▇▇ █
  2.6 μs<span class="sgr90">       Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>      3.58 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code></pre><h3 id="Allocation-free-computations"><a class="docs-heading-anchor" href="#Allocation-free-computations">Allocation-free computations</a><a id="Allocation-free-computations-1"></a><a class="docs-heading-anchor-permalink" href="#Allocation-free-computations" title="Permalink"></a></h3><p>The sizes of the arrays associated with all nodes become known as the graph is built, which means that memory can be pre-allocated to store the values associated with every node. </p><p>In practice, this means that calls to <a href="lib_public.html#ComputationGraphs.set!">set!</a>, <a href="lib_public.html#Base.copyto!">copyto!</a>, <a href="lib_public.html#Base.get">get</a>, and <a href="lib_public.html#ComputationGraphs.compute!">compute!</a> are typically allocation free, as reported above by <code>@benchmark</code>. This greatly contributes to minimizing garbage collection and keeping the compute times small and fairly predictable.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="man_differentiation.html">Symbolic differentiation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 12 September 2025 06:14">Friday 12 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
